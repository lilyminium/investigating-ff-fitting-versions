import click
import pathlib
import shutil
import tqdm

OPTIMIZE = """\
# ForceBalance input file generated by MakeInputFile.py
# The octothorpe '#' is a comment symbol
# Note: If the specified value is 'None' then the option will truly be set to None - not the string 'None'
# Note: 'Section' option types are more complicated and may require you to read the documentation
# Note: Boolean option types require no value, the key being present implies 'True'

$options
# (string) Directory containing force fields, relative to project directory
ffdir ../../../forcefield

# (string) Type of the penalty, L2 or L1 in the optimizer
penalty_type L2

# (allcap) The job type, defaults to a single-point evaluation of objective function
jobtype single

# (list) The names of force fields, corresponding to directory forcefields/file_name.(itp|gen)
forcefield force-field.offxml

# (int) Maximum number of steps in an optimization
maxstep 1

# (float) Convergence criterion of step size (just needs to fall below this threshold)
convergence_step 0.01

# (float) Convergence criterion of objective function (in MainOptimizer this is the stdev of x2 over 10 steps)
convergence_objective 0.1

# (float) Convergence criterion of gradient norm
convergence_gradient 0.1

# The number of convergence criteria that must be met for main optimizer to converge
criteria 2

# (float) Minimum eigenvalue for applying steepest descent correction in the MainOptimizer
eig_lowerbound 0.01

# (float) Step size for finite difference derivatives in many functions (get_(G/H) in fitsim, FDCheckG)
finite_difference_h 0.01

# (float) Factor for multiplicative penalty function in objective function
penalty_additive 1.0

trust0 -1.0
error_tolerance 1.0
normalize_weights False
# any extras are added here like print hessian
wq_port  {port}
asynchronous  True
backup  0
retain_micro_outputs  0

# Charge constraints are taken care of using "evals".
constrain_charge false

priors
   Angles/Angle/k :  100.0
   Angles/Angle/angle :  5.0
   Bonds/Bond/k :  100.0
   Bonds/Bond/length :  0.1
   ProperTorsions/Proper/k :  5.0
   ImproperTorsions/Improper/k :  5.0
/priors

$end

$target
name {opt_geo_name}
weight 0.01

type OptGeoTarget_SMIRNOFF

writelevel 1
remote 0
$end
"""


SUBMIT = """\
#!/bin/bash
#
# Set the job name and wall time limit
#BSUB -J master_{counter}_{short_environment}
#BSUB -W 168:00
#
# Set the output and error output paths.
#BSUB -o  master_{counter}_{short_environment}-%J.o
#BSUB -e  master_{counter}_{short_environment}-%J.e
#
# Set any cpu options.
#BSUB -M 2

# ===================== conda environment =====================

source ~/.bashrc
micromamba activate {environment}

micromamba env export > fitting-environment.yaml

export OE_LICENSE="/home/lilywang/oe_license.txt"

mkdir working-directory

ForceBalance.py optimize.in > force_balance.log
"""

@click.command()
@click.option(
    "--target-directory",
    type=click.Path(exists=True, file_okay=False, dir_okay=True),
    required=True,
)
@click.option(
    "--start-number",
    type=int,
    required=True,
)
@click.option(
    "--environment",
    "environments",
    type=str,
    required=True,
    multiple=True,
)
@click.option(
    "--n-reps",
    type=int,
    default=1,
)
def setup_target_optgeo_batches(
    target_directory,
    start_number: int,
    environments: list[str],
    n_reps: int = 1,
):
    target_directory = pathlib.Path(target_directory)

    counter = start_number
    for optgeo_directory in tqdm.tqdm(
        sorted(
            target_directory.glob("opt*"),
            key=lambda x: int(x.stem.split("-")[-1]),
        )
    ):
        comparison_directory = pathlib.Path(f"{counter:03d}_{optgeo_directory.stem}")
        comparison_directory.mkdir(exist_ok=True)

        # set up targets
        comparison_target_directory = comparison_directory / "targets"
        comparison_target_directory.mkdir(exist_ok=True)
        shutil.copytree(
            optgeo_directory,
            comparison_target_directory / optgeo_directory.stem,
        )

        for i, environment in enumerate(environments):

            environment_directory = comparison_directory / environment
            environment_directory.mkdir(exist_ok=True)

            for n_rep in range(n_reps):
                n_rep += 1
                rep_directory = environment_directory / f"rep{n_rep}"
                rep_directory.mkdir(exist_ok=True)

                port = n_rep * 10000 + counter + (i * 1000)

                # write optimize.in
                optimize_file = rep_directory / "optimize.in"
                optimize_file.write_text(
                    OPTIMIZE.format(
                        port=port,
                        opt_geo_name=optgeo_directory.stem,
                    )
                )

                # write submit.sh
                submit_file = rep_directory / "submit.sh"
                submit_file.write_text(
                    SUBMIT.format(
                        counter=counter,
                        short_environment=environment.split("-")[1],
                        environment=environment,
                    )
                )

                # set up targets
                environment_target_directory = rep_directory / "targets"
                environment_target_directory.symlink_to(
                    comparison_target_directory.resolve(),
                )
        counter += 1




if __name__ == "__main__":
    setup_target_optgeo_batches()